# エラー処理

## エラー型の実装

以下のインターフェースを満たすものはすべてエラー型として扱われる

```Go
interface error {
  Error() string
}
```

## 単純なオリジナルエラーの作成

- errors.New 関数: Error 関数で返却される文字列を指定してエラーを作成する
- fmt.Errorf: Error 関数で返却される文字列をフォーマット指定してエラーを作成する

以下に errors.New 関数の実装を示す。

```Go
package errors

func New(text string) error {
	return &errorString{text}
}

type errorString struct {
	s string
}

func (e *errorString) Error() string {
	return e.s
}
```

errors.New 関数は error 型を返却する。error 型はインターフェースなので型として errorString を、値として errorString のポインター（アドレス値）を持つ。

## センチネルエラー

パッケージレベルで error 型の変数 を定義し、エラーの受け取り手が「==」を使ってどのエラーが返却されたか条件分岐できるようにする。  
センチネルエラーのパッケージレベルで宣言する変数名は「Err」で始める。

```Go
// errorString構造体のポインター
var ErrOriginal = errors.New("original error")

func returnError() error {
	return ErrOriginal
}

func main() {
	err := returnError()
	if err != nil {
		if err == ErrOriginal {
			println("error")
		}
	}
}
```

ErrOriginal はパッケージレベルで定義される。ErrOriginal は構造体のポインターであり、`err == ErrOriginal`はアドレス値同士を比較している。もし errors.New 関数が構造体自体を返却していた場合、errString 構造体のフィールド s 文字列が一致すれば ErrOriginal とみなされてしまうため errors.New が構造体のポンターを返却することは理にかなっている。

## 複雑なオリジナルエラー作成

`error`型は Error 関数を実装しさえすればよいので、構造体を定義し構造体のメソッドとして Error メソッドを定義することでオリジナルの複雑なエラーを作成できる。

```Go
package main

type Status int

const (
	InvalidLogin Status = iota + 1
	NotFound
)

type StatusErr struct {
	Status  Status
	Message string
}

func (se StatusErr) Error() string {
	return se.Message
}
```

## エラーのラップ

エラーをラップすることができる。

1. fmt.Errorf("%w", err)を使用する
2. オリジナルのエラーに Unwrap 関数を実装する

fmt.Errorf の実装

```Go
func Errorf(format string, a ...any) error {
  switch len(wrappedErrs) {
	case 0:
		err = errors.New(s)
	case 1:
		w := &wrapError{msg: s}
		return w
  }
}

type wrapError struct {
	msg string
	err error
}

func (e *wrapError) Error() string {
	return e.msg
}

func (e *wrapError) Unwrap() error {
	return e.err
}
```

オリジナルエラーの実装

```Go
type Status int

const (
	InvalidLogin Status = iota + 1
	NotFound
)

type StatusErr struct {
	Status  Status
	Message string
	Cause error
}

func (se StatusErr) Error() string {
	return se.Message
}

func (se StatusErr) Unwrap() error {
	return se.Cause
}
```

## errors.Is と errors.As

errors.Is 関数と errors.As 関数はラップされたエラーのチェーンをさかのぼってくれる。

- errors.Is 関数: 「==」比較する
- errors.As 関数: 型アサーションする

errors.Is 関数

```Go
var ErrOriginal = errors.New("original error")

func main() {
	err := fmt.Errorf("cause:  %w", ErrOriginal)
	errors.Is(err, ErrOriginal)
}
```

errors.As 関数

```Go
err := returnErr()
var statusErr StatusErr
if errors.As(err, &statusErr) {
	println(statusErr.Message)
}
```

型アサーションして取得できた具象型は第二引数に代入される。

errors.Is 関数は Is メソッドを定義することで独自の挙動を実現できる。

```Go
type Status int

const (
	InvalidLogin Status = iota + 1
	NotFound
)

type StatusErr struct {
	Status  Status
	Message string
	Cause   error
}

func (se StatusErr) Error() string {
	return se.Message
}

func (se StatusErr) Unwrap() error {
	return se.Cause
}

// ステータスが一致していれば同一エラーとみなす
func (se StatusErr) Is(target error) bool {
	if err, ok := target.(StatusErr); ok {
		return se.Status == err.Status
	}
	return false
}
```
